{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f0b9c0f5_adc5bce9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2024-11-05T21:33:18Z",
      "side": 1,
      "message": "I think this is the right approach, thanks for doing this! I\u0027ll ping one of the libavb owners as well and get their input but I think it shouldn\u0027t be too contentious.",
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d703c4f0_1f9e02a6",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2024-11-05T21:33:18Z",
      "side": 1,
      "message": "nit: it\u0027s fairly common to \"extend\" a structure in C to pair it with additional data, e.g.\n\n```\nstruct MyAvbHashOps {\n  // Since AvbHashOps is the first member here, we can pass in MyAvbHashOps*\n  // wherever AvbHashOps* is expected - their pointers are identical - and then\n  // convert back in the callback implementations to get our data out.\n  AvbHashOps hash_ops;\n  MyExtraData data;\n}\n```\n\nonly listing those two approaches makes it seem like we\u0027re prohibiting this technique, was that the intention?",
      "range": {
        "startLine": 98,
        "startChar": 3,
        "endLine": 98,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92052bdd_2a166ece",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2024-11-07T17:16:25Z",
      "side": 1,
      "message": "Didn\u0027t know about it, extremely useful one, huge thanks! Already applied this approach to implement `DefaultAvbHashOps`.",
      "parentUuid": "d703c4f0_1f9e02a6",
      "range": {
        "startLine": 98,
        "startChar": 3,
        "endLine": 98,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "534f9b04_b51beebf",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2024-11-05T21:33:18Z",
      "side": 1,
      "message": "If we go forward with this approach it would be useful to provide either a compile-time flag to skip this, or a reference implementation that implements them as no-ops, to minimize the amount of boilerplate needed.",
      "range": {
        "startLine": 141,
        "startChar": 54,
        "endLine": 143,
        "endChar": 71
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b60072c0_4eff2a5a",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2025-01-23T20:54:13Z",
      "side": 1,
      "message": "Get rid of this requirement.",
      "parentUuid": "534f9b04_b51beebf",
      "range": {
        "startLine": 141,
        "startChar": 54,
        "endLine": 143,
        "endChar": 71
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9c05ed5_99423831",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 147,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2024-11-05T21:33:18Z",
      "side": 1,
      "message": "I would lean towards just a single `hash_ops` struct if possible; e.g. maybe we could just pass the requested algorithm as a parameter to `init()` to differentiate 256 vs 512?",
      "range": {
        "startLine": 147,
        "startChar": 11,
        "endLine": 147,
        "endChar": 41
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "090cdfc5_607f4c7b",
        "filename": "libavb/avb_ops.h",
        "patchSetId": 1
      },
      "lineNbr": 147,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2024-11-07T17:16:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c9c05ed5_99423831",
      "range": {
        "startLine": 147,
        "startChar": 11,
        "endLine": 147,
        "endChar": 41
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8d89d10_2ba7c57a",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2024-11-05T21:33:18Z",
      "side": 1,
      "message": "optional: it might help clean up implementation to always go through the hash ops struct; if the `AvbOps` that the caller provides doesn\u0027t contain its own hashing ops, we can just hook in our own that routes through the global hash functions. e.g. maybe something like:\n\n```\nAvbHashOps* hash_ops \u003d ops-\u003ehash_ops ? ops-\u003ehash_ops : kGlobalHashOps;\n```",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa2854f0_e46e7dee",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2024-11-07T17:16:25Z",
      "side": 1,
      "message": "Done. Defined `kDefaultAvbHashOps` in new introduced `avb_sha.c`. Thank you!",
      "parentUuid": "c8d89d10_2ba7c57a",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b800d4d1_44296090",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2025-01-23T21:23:31Z",
      "side": 1,
      "message": "I discovered a problematic issue with the static `kDefaultAvbHashOps`. GBL runs all tests in parallel using threads, which means all libavb sessions are sharing the same static `kDefaultAvbHashOps` object. This leads to concurrent hash calculations.\n\nThe most straightforward fix would be to continue using stack-allocated `hash_ctx`, ensuring that calculations are isolated. However, the context size must be determined at compile time, which isn\u0027t very convenient for runtime-provided `HashOps`.\n\nAnother potential solution is to make `defaultAvbHashOps` a part of `AvbOps`, isolating it per session. However, this approach feels not very clean.\n\n@dpursell@google.com I feel a bit stuck. Am I overlooking something? Do you have any ideas?",
      "parentUuid": "fa2854f0_e46e7dee",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c746217e_f712fb3b",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2025-01-23T23:29:36Z",
      "side": 1,
      "message": "Ah shoot, sorry that didn\u0027t occur to me.\n\nI think if we want this to work in all contexts the old one did (e.g. thread-safe by default) we will need to stack-allocate the default context here. But since we\u0027re already stack-allocating in the current implementation it\u0027s not much different, and we could even possibly make the 256/512 contexts a `union` to optimize it a bit and make it better than the current.\n\nWe could also use the `AVB_FORCE_HASH_OPS` define as an optimization to remove the stack allocation altogether, so maybe something like:\n\n```\ntypedef struct {\n  AvbHashOps ops;\n  AvbDigestType type;\n  union {\n    AvbSHA256Ctx sha256_context;\n    AvbSHA512Ctx sha512_context;\n  };\n} DefaultAvbHashOps;\n```\n\n```\n#ifdef AVB_FORCE_HASH_OPS\nAvbHashOps* hash_ops \u003d ops-\u003ehash_ops;\navb_assert(hash_ops !\u003d NULL);  \n#else\nDefaultAvbHashOps default_ops;\nAvbHashOps* hash_ops \u003d ops-\u003ehash_ops ? ops-\u003ehash_ops : \u0026default_ops;\n#endif\n\nhash_ops-\u003einit(hash_ops, digest_type);\nhash_ops-\u003eupdate(hash_ops, desc_salt, hash_desc.salt_len);\nhash_ops-\u003eupdate(hash_ops, image_buf, image_size_to_hash);\ndigest \u003d hash_ops-\u003efinalize(hash_ops);\n```\n\nDoes it seem like that would work? It is admittedly a bit uglier, but I can\u0027t think of a better way off the top of my head.",
      "parentUuid": "b800d4d1_44296090",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21e4c763_1ea76c23",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1893074
      },
      "writtenOn": "2025-01-24T17:29:02Z",
      "side": 1,
      "message": "Thank you very much for the suggestion, looks like a good middleground. Applied this approach, get rid of boileprate by introducing a macro. Does it look good?",
      "parentUuid": "c746217e_f712fb3b",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58e61eda_36dff7be",
        "filename": "libavb/avb_slot_verify.c",
        "patchSetId": 1
      },
      "lineNbr": 408,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2025-01-24T18:27:07Z",
      "side": 1,
      "message": "Yeah I think this will work well, thanks!",
      "parentUuid": "21e4c763_1ea76c23",
      "range": {
        "startLine": 404,
        "startChar": 0,
        "endLine": 408,
        "endChar": 42
      },
      "revId": "16326e79062da099eaf39024a54256217aae8051",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}