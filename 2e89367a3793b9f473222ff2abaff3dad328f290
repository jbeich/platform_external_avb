{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6633aae2_2fd2dfa7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "Hi David,\n\nThanks for the work and sorry again for the late review..",
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6230f27_8ecfd3b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "Np :)\n\nI was thinking that maybe some of the differences of opinion here come from a slightly different vision of what this library would look like.\n\nI was envisioning that this library would be a bit of a \"thicker\" wrapper, where it\u0027s responsible for hiding all the FFI weirdness so that the users can interact with libavb in a more idiomatic Rust way.\n\nI think that maybe your vision is maybe more of a \"thinner\" wrapper which provides an API that mirrors the C API more closely, mostly just handling any `unsafe` conversions internally?\n\nIf that\u0027s the case, then I\u0027m happy to switch over to more of a thin approach, and most of my comments here can be disregarded. Given that pvmfw already interfaces with a thinner-style API and that\u0027s the primary use case, it seems reasonable to stick with it if that what you\u0027d prefer.",
      "parentUuid": "6633aae2_2fd2dfa7",
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69aa1622_3c5ed7bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-11T09:28:35Z",
      "side": 1,
      "message": "Thanks for the explanation. I did expect a thinner wrapper mostly that allows libavb to be called in Rust in a relatively safer way in comparison with calling the binding directly :) \n\nAs said in the other thread, maybe we can document the target API in a doc first, because based on the current cl I still don\u0027t see how the main entry point `verify_avb_slot` is going to interact with the trait defined here. Just to make sure that everyone is on the same page about the direction. wdyt?",
      "parentUuid": "d6230f27_8ecfd3b7",
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70b1d8aa_7b783484",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-12T00:43:00Z",
      "side": 1,
      "message": "Sounds good, I uploaded the other changes for the time being, and I will start writing up an API doc and try to have it ready in the next day or two.",
      "parentUuid": "69aa1622_3c5ed7bb",
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e13ba280_98ebc0c7",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "It\u0027s more clear to make all the functions in this API return `Result\u003cT, IoError\u003e`. It\u0027s more coherent and easier for users to implement. `Option` doesn\u0027t support `?`.",
      "range": {
        "startLine": 68,
        "startChar": 62,
        "endLine": 68,
        "endChar": 75
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36afef65_fb034893",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "This function has very similar functionality as `read_from_partition`, just but it operates on preloaded data and circumvents the need for new memory allocation. Why it has completely different signature compared the other one here?\n\nTBH, I believe it would be advantageous to maintain a consistent set of APIs with the C code. Since the Rust library primarily serves as a wrapper, having the same function and parameters names would be more intuitive and straightforward.",
      "range": {
        "startLine": 68,
        "startChar": 7,
        "endLine": 68,
        "endChar": 30
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d398220_c0627923",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "\u003e Why it has completely different signature compared the other one here?\n\nIn addition to avoiding allocation, it is also a zero-copy operation i.e. it provides a pointer to a user-owned buffer rather than filling an avb-owned buffer. So the signature has to be different because the implementation is giving a pointer rather than receiving a pointer (similar to how the [C ops](https://cs.android.com/android/platform/superproject/main/+/main:external/avb/libavb/avb_ops.h;l\u003d129) signature differs between these two APIs).\n\n\u003e having the same function and parameters names would be more intuitive and straightforward.\n\nMy goal here was to mirror the C API but in a more idiomatic Rust way so that the user doesn\u0027t have to interact with unsafe code or FFI types. The function names are identical, but some parameters which are awkward or unsafe in Rust get modified, e.g. a (pointer + size) buffer is more naturally represented in Rust as a slice, and out-params are less common since it\u0027s more idiomatic to instead return a `Result\u003c\u003e` that can contain the output or an error code.",
      "parentUuid": "36afef65_fb034893",
      "range": {
        "startLine": 68,
        "startChar": 7,
        "endLine": 68,
        "endChar": 30
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d18ef228_8f832b74",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "Ack, I was wondering myself if it would be easier just to stick with `Result` here. The tricky thing is that there\u0027s a difference between \"I don\u0027t have this partition preloaded\" (which continues on to the normal load) and \"an error occurred\" (which exits immediately), so it will have to be `Result\u003cOption\u003cT\u003e IoError\u003e` in this case to be able to distinguish between these conditions, but that seems fine.\n\n(Side note: if I\u0027m reading the docs correctly, [`Option` does support `?`](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator), but it does seem to be a far less common usage so I\u0027m happy to switch back to `Result`.)",
      "parentUuid": "e13ba280_98ebc0c7",
      "range": {
        "startLine": 68,
        "startChar": 62,
        "endLine": 68,
        "endChar": 75
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "286857da_5bce5296",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-11T09:28:35Z",
      "side": 1,
      "message": "I see, thanks for the explanation. Another thing is that not all the functions are supposed to be implemented by users. How are you going to allow users not to implement certain functions in the trait?\n\nMaybe it\u0027s easier to summarise how the target rust API and entry point function will look like in a doc, so that everyone knows what all these incremental cls lead to?",
      "parentUuid": "8d398220_c0627923",
      "range": {
        "startLine": 68,
        "startChar": 7,
        "endLine": 68,
        "endChar": 30
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d51d379c_5cb55896",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-12T00:43:00Z",
      "side": 1,
      "message": "\u003e How are you going to allow users not to implement certain functions in the trait?\n\nThe optional callbacks will have a default implementation defined in the trait (as how `get_preloaded_partition()` has a default implementation that returns `None`)\n\n\u003e Maybe it\u0027s easier to summarise how the target rust API and entry point function will look like in a doc, so that everyone knows what all these incremental cls lead to?\n\nAck will do.",
      "parentUuid": "286857da_5bce5296",
      "range": {
        "startLine": 68,
        "startChar": 7,
        "endLine": 68,
        "endChar": 30
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65a9535a_7450ad90",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-12T13:43:33Z",
      "side": 1,
      "message": "\u003e The optional callbacks will have a default implementation defined in the trait (as how get_preloaded_partition() has a default implementation that returns None)\n\nSo we return `Result\u003cOption\u003c\u0026[u8]\u003e\u003e` instead of `Result\u003c\u0026[u8]\u003e` only to detect whether users have implemented the function? Mm, tbh I feel `Result\u003cOption\u003e\u003e` a bit heavy and not so straight-forward. \n\nWhat about still returning `Result\u003c\u0026[u8]\u003e` and just raise an `IoError::FunctionUnimplemented` error as default implementation? We just can forward this error with `?` in `try_**` and in `result_to_io_enum()` we can convert this to the `*_OK` enum.",
      "parentUuid": "d51d379c_5cb55896",
      "range": {
        "startLine": 68,
        "startChar": 7,
        "endLine": 68,
        "endChar": 30
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5df72a4e_8808008f",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "This looks a bit awkward. Can we just make this consistent with the C API, to pass `\u0026mut out_num_read` as param and return `Result\u003c(), IoError\u003e`?\n\nThen here we can just call `ops.read_from_partition([Rust type params])` directly.",
      "range": {
        "startLine": 200,
        "startChar": 8,
        "endLine": 200,
        "endChar": 47
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e86601d4_8c04c74b",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "IMO hiding awkwardness inside the library is better than requiring the user to deal with it.\n\nOut-params are too easy to forget to set in all code paths and aren\u0027t always clear on expectations e.g. what if the function fails early, do we still need to set the output param? http://go/totw/176 is written for C++ so not all the reasoning applies, but I think the overall idea of \"prefer return values over output params when possible\" still holds in Rust.\n\nThis code itself is a good example - do we actually need to write 0 to `out_num_read` on failure? Or could we just `return Err()` directly here:\n\n```\nmatch ops.read_from_partition(...) {\n  Ok(bytes_read) \u003d\u003e {\n    unsafe { write_checked(...) }\n    Ok(())\n  }\n  Err(e) \u003d\u003e Err(e)\n}\n```\n\nIn this particular case I\u0027m reasonably certain libavb will do the right thing if I just return an error and it won\u0027t try to use `out_num_read`, but the function documentation doesn\u0027t say either way, so as a library user if I want to be as safe as possible I should cover this condition and write to the output params even on failure.",
      "parentUuid": "5df72a4e_8808008f",
      "range": {
        "startLine": 200,
        "startChar": 8,
        "endLine": 200,
        "endChar": 47
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62724642_5749cf24",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-11T09:28:35Z",
      "side": 1,
      "message": "It\u0027s okay to write 0. It\u0027s just the style of converting result to tuple and then returning the result, that I feel a bit atypical. What about writing a default and then forwarding the error as you said?\n```\n// SAFETY: `out_num_read` is non-null and properly allocated by libavb.\nunsafe { ptr::write(out_num_read, 0); }\nlet bytes_read \u003d ops.read_from_partition(partition, offset, buffer)?;\n// SAFETY: `out_num_read` is non-null and properly allocated by libavb.\nunsafe { ptr::write(out_num_read, bytes_read); }\nOk(())\n```\n\nWe can do the same for the other function.",
      "parentUuid": "e86601d4_8c04c74b",
      "range": {
        "startLine": 200,
        "startChar": 8,
        "endLine": 200,
        "endChar": 47
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e5e1bda_1ea427cc",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-12T00:43:00Z",
      "side": 1,
      "message": "Gotcha, I was mostly trying to avoid multiple unsafe blocks since that seemed to be the most awkward part, but if the tuple assignment is unusual I\u0027ll switch over to this approach.",
      "parentUuid": "62724642_5749cf24",
      "range": {
        "startLine": 200,
        "startChar": 8,
        "endLine": 200,
        "endChar": 47
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2605b8cd_b4f4dc4d",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "As discussed offline, I don\u0027t think we really need the lifetime parameter and the helper functions here, since if we call the original Rust function, anyway the returned reference is only valid for the lifetime of the function.",
      "range": {
        "startLine": 245,
        "startChar": 5,
        "endLine": 245,
        "endChar": 21
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "233e7a8d_92c15211",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "Done.\n\nI left `cstr_to_str()` for now pending the discussion below, and added some null-pointer helpers to reduce a common 3-4 line boilerplate to an inline `?`, but the lifetime-related APIs have been removed.",
      "parentUuid": "2605b8cd_b4f4dc4d",
      "range": {
        "startLine": 245,
        "startChar": 5,
        "endLine": 245,
        "endChar": 21
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da979385_9361d959",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 253,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "It\u0027s convenient to pass `\u0026CStr` around as well in ffi code. We don\u0027t need to make everything from ptr to \u0026CStr then to `\u0026str`.",
      "range": {
        "startLine": 253,
        "startChar": 37,
        "endLine": 253,
        "endChar": 40
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8494961b_a32ffc06",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 253,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "Since this is passed into the user-implemented ops, providing it to them as a standard Rust `\u0026str` avoids requiring them to interface with FFI types.\n\nIn the pvmfw code for example, passing this around as a `CStr` eventually requires specifying the expected partition names as [raw bytestrings with explicit manual nul-termination](https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/Virtualization/pvmfw/avb/src/partition.rs;l\u003d32) rather than a more natural string type. It\u0027s not a huge deal, but maybe a slight inconvenience/awkwardness for the user that could be avoided.",
      "parentUuid": "da979385_9361d959",
      "range": {
        "startLine": 253,
        "startChar": 37,
        "endLine": 253,
        "endChar": 40
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1154a2d_cba6e378",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 253,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-11T09:28:35Z",
      "side": 1,
      "message": "When working with \u0026str, two conversions are required: from a pointer to \u0026CStr, and from \u0026CStr to \u0026str. This can lead to confusion regarding lifetimes. Without the lifetime parameter in the helper function, the lifetime of the returned \u0026str would be tied to the \u0026CStr living with the scope of the helper function from the first look.\n\nIf you really want the API to take \u0026str, would it be easier to make the 2-step conversion directly in the callers instead of having a helper function?",
      "parentUuid": "8494961b_a32ffc06",
      "range": {
        "startLine": 253,
        "startChar": 37,
        "endLine": 253,
        "endChar": 40
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c74b2a1_80e0a10e",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 253,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-12T00:43:00Z",
      "side": 1,
      "message": "Ack that makes sense thanks for explaining, used the suggested approach to store the `\u0026CStr` locally then convert to `\u0026str` when passing to the caller.",
      "parentUuid": "b1154a2d_cba6e378",
      "range": {
        "startLine": 253,
        "startChar": 37,
        "endLine": 253,
        "endChar": 40
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdcbb3e6_ea718536",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 269,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-09-08T19:04:58Z",
      "side": 1,
      "message": "I\u0027m a bit confused as to why this function returns \u0026[u8] as output, while the other read_partition function writes the output \u0026[u8] in a parameter. Moreover, both of them differ from the C API.\n\nIMO, it would be more advantageous to adhere to the C API for the operations defined here.\n\nhttps://cs.android.com/android/platform/superproject/main/+/main:external/avb/libavb/avb_ops.h?ss\u003dandroid%2Fplatform%2Fsuperproject%2Fmain\u0026q\u003df:external%20f:avb%20f:ops.h",
      "range": {
        "startLine": 269,
        "startChar": 8,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca16ea7f_e7bfe20c",
        "filename": "rust/src/verify.rs",
        "patchSetId": 5
      },
      "lineNbr": 269,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-09-09T00:44:24Z",
      "side": 1,
      "message": "Added some thoughts in a comment at the top.",
      "parentUuid": "bdcbb3e6_ea718536",
      "range": {
        "startLine": 269,
        "startChar": 8,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "2e89367a3793b9f473222ff2abaff3dad328f290",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}