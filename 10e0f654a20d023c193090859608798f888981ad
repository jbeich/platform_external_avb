{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "16f63f04_8b6b7b7d",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-23T23:59:10Z",
      "side": 1,
      "message": "These APIs feel overly-complicated, but they mirror what libavb requires. LMK if you can think of any better way to express this in Rust without deviating from the original libavb API too much.\n\nI thought about using `Option\u003c\u003e` so that `None` could be the query-only case rather than a 0-length slice, but I think it just makes it harder on the user since they now have to handle 3 cases (None, too small, big enough) rather than just 2 (too small, big enough).",
      "range": {
        "startLine": 155,
        "startChar": 0,
        "endLine": 158,
        "endChar": 72
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d33ed0b2_68f16045",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-10-24T14:26:10Z",
      "side": 1,
      "message": "I think the current API is fine. It\u0027s quite common to provide a buffer for writing and return a `BufferTooShort/Small`[1] error with the actual size when the provided buffer is not big enough.\n\n[1] https://cs.android.com/search?q\u003dBufferToo*%20l:rs\u0026ss\u003dandroid%2Fplatform%2Fsuperproject%2Fmain",
      "parentUuid": "16f63f04_8b6b7b7d",
      "range": {
        "startLine": 155,
        "startChar": 0,
        "endLine": 158,
        "endChar": 72
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da2b8533_e2a618c7",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 176,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-10-24T14:26:10Z",
      "side": 1,
      "message": "t seems a bit unconventional to use `Option` for splitting the write function into write and erase. Perhaps it would be better to provide two separate APIs instead?\n```\nfn write_persistent_value(\u0026mut self, name: \u0026CStr, value: \u0026[u8]) -\u003e Result\u003c()\u003e\nfn delete_persistent_value(\u0026mut self, name: \u0026CStr) -\u003e Result\u003c()\u003e\n```",
      "range": {
        "startLine": 176,
        "startChar": 55,
        "endLine": 176,
        "endChar": 89
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54dc3557_572d9457",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 176,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-24T23:49:22Z",
      "side": 1,
      "message": "Yeah I think that\u0027s nicer, it deviates from the libavb C API but seems worth it. Done.",
      "parentUuid": "da2b8533_e2a618c7",
      "range": {
        "startLine": 176,
        "startChar": 55,
        "endLine": 176,
        "endChar": 89
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a16d28fa_46e18ce2",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 860,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-10-24T14:26:10Z",
      "side": 1,
      "message": "Should we also handle NotImplemented error since these methods are not always required?",
      "range": {
        "startLine": 860,
        "startChar": 53,
        "endLine": 860,
        "endChar": 59
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faa72036_6958084c",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 860,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-24T23:49:22Z",
      "side": 1,
      "message": "The `result?` below will properly convert `NotImplemented` into something libavb understands (generic `IoError`) in the case that it\u0027s needed but not implemented.\n\nThe reason we have to specifically handle `InsufficientSpace` here instead is because we have to extract the actual space required and write it to the out-param before we bubble the error up (should hopefully be more readable with the below adjustments).",
      "parentUuid": "a16d28fa_46e18ce2",
      "range": {
        "startLine": 860,
        "startChar": 53,
        "endLine": 860,
        "endChar": 59
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bf0adbe_17bce526",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 860,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-10-26T07:33:15Z",
      "side": 1,
      "message": "I understand that this code will propagate the error to the caller e.g `avb_slot_verify`. However, I\u0027m uncertain whether the caller will function correctly in this scenario. Since we have provided a valid `read_persistent_value` argument in `AvbOps`, the caller will attempt to read the value, but it will hit an error if `read_persistent_value` is not implemented in the trait. This looks incoherent with the assumption that the function can be optional.\n\nShould we skip the `NotImplemented` error, similar to what is done in `get_preloaded_partition` [1]?\n\n[1] https://cs.android.com/android/platform/superproject/main/+/main:external/avb/rust/src/verify.rs;l\u003d425;drc\u003da3f9b5f7bf6183b8077d6072071d0cf1d23656f9",
      "parentUuid": "faa72036_6958084c",
      "range": {
        "startLine": 860,
        "startChar": 53,
        "endLine": 860,
        "endChar": 59
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d8ba0fb_2f851c34",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 860,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-26T22:06:31Z",
      "side": 1,
      "message": "`get_preloaded_partition()` is an optional optimization; libavb is OK with calling this function even if it\u0027s not implemented, since it will have a fallback path by calling `read_from_partition()` instead. libavb docs say we can indicate this is unimplemented by setting the out pointer to NULL and returning success, which is why we can map unimplemented -\u003e success here.\n\nThe persistent value callbacks are slightly different; they are optional in the sense that they will not be called unless certain features are requested (it\u0027s not the absence or presence of the function pointer that tells libavb to use these callbacks, but just whether the feature flags are set or not). So mapping unimplemented -\u003e success is not appropriate here; if libavb calls these functions, they must work.\n\nI\u0027ll remove the default implementation in the trait for now, it may be misleading, and this will at least force users to look at these functions and explicitly decide if they need to implement them or not.",
      "parentUuid": "5bf0adbe_17bce526",
      "range": {
        "startLine": 860,
        "startChar": 53,
        "endLine": 860,
        "endChar": 59
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01f7619d_e2d33df5",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 873,
      "author": {
        "id": 1958315
      },
      "writtenOn": "2023-10-24T14:26:10Z",
      "side": 1,
      "message": "nit: I think this part can be more clear if we match the result directly.",
      "range": {
        "startLine": 859,
        "startChar": 4,
        "endLine": 873,
        "endChar": 10
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b98fa36_a13d0ab6",
        "filename": "rust/src/verify.rs",
        "patchSetId": 2
      },
      "lineNbr": 873,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-24T23:49:22Z",
      "side": 1,
      "message": "Ack yeah this is a bit awkward. Tried switching to `match` which was better, then realized I could combine the success and insufficient case handling into a single `if` which seemed even nicer, but LMK if it still feels like `match` would work better here.",
      "parentUuid": "01f7619d_e2d33df5",
      "range": {
        "startLine": 859,
        "startChar": 4,
        "endLine": 873,
        "endChar": 10
      },
      "revId": "10e0f654a20d023c193090859608798f888981ad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}